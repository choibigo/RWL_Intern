# Chap_04 컴프리헨션과 제너레이터

## **27. map과 filter 대신 컴프리헨션을 사용하라**

- 왜 컴프리헨션인가?
    - **수학적 의미:** 수학에서 집합을 정의할 때 `{ x² | x ∈ A }` (A에 속하는 x에 대하여 x의 제곱들의 집합)와 같이 정의하는 방식을 '포괄적 정의'라고 한다.
    - 'Comprehension'은 '이해'라는 뜻도 있지만, 어떤 것들을 '포괄'하거나 '포함'한다는 뜻이 있다.
    
    즉, "리스트가 담아야 할 내용(조건과 공식)을 한 구문 안에 모두 포괄하고 있다"는 뜻에서 컴프리헨션이라는 이름이 붙었다
    

```python
a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
squares = []
for x in a:
    squares.append(x**2)

print(squares)
```

- 일반적인 `for` 루프의 방식
    - 작동방식 : 빈 리스트를 만들고, 원본 데이터를 하나씩 꺼내 계산한 뒤 `append` 로 집어 넣는다.
    - 시각적인 노이즈가 많다고 한다

```python
squares = [x**2 for x in a] # 리스트 컴프리핸션
print(squares)
```

- 리스트 컴프리헨션 기본 형
    - for 루프의 로직을 한줄로 압축
    - "a에 있는 x에 대해 x의 제곱을 수행한다"는 의도가 한눈에 보인다.
        - 파이썬 인터프리터 내부에서 `append` 를 반복 호출하는 것보다 리스트 컴프리헨션이 C 수준에서 더 빠르게 동작한다.

```python
alt = map(lambda x: x ** 2, a)
```

- `map` 함수 활용
    - `map(함수, 데이터)`
        - 첫 번째 인자 : 적용할 함수(`lambda x: x ** 2`)
        - 두 번째 인자 : 데이터를 꺼내올 반복 가능한 객체(리스트 `a` )

```python
even_squares = [x**2 for x in a if x % 2 == 0]
print(even_squares)
```

- 필터링이 추가된 컴프리헨션
    - `for x in a`: `a`에서 요소를 꺼낸다.
    - `if x % 2 == 0`: 짝수인지 확인한다 (필터).
    - `x**2`: 조건에 맞으면 제곱한다 (변환).
    - `[...]`: 결과들을 모아 새 리스트를 만든다.

```python
alt = map(lambda x: x**2, filter(lambda x: x % 2 == 0, a))
assert even_squares == list(alt)
```

- `map` 과 `filter` 까지 중첩시킨 형태
    - `filter(lambda x: x % 2 == 0, a)`
        - filter 함수는 조건에 맞는 요소만 걸러낸다
            - 첫번째 인자 : 조건함수 `lambda x: x % 2 == 0` 에 대해 결과가 `True` 인것만 남긴다.
            - 두번째 인자 : 대상 데이터(`a`)
            - 결과 : 리스트 `a` 에서 짝수(2,4,6,8,10)만 통과시켜 다음 단계로 넘겨준다.
    - `map(lambda x: x**2, ...)`
        - filter 가 걸러낸 결과물을 map 이 받는다.
    - 여기서 문제
        - 안쪽(`filter`)에서 바깥쪽(`map`)으로 읽어야 한다.

```python
even_squares_dict = {x: x**2 for x in a if x % 2 == 0}
threes_cubed_set = {x**3 for x in a if x % 3 == 0}
print(even_squares_dict)
print(threes_cubed_set)
```

```python
{2: 4, 4: 16, 6: 36, 8: 64, 10: 100}
{216, 729, 27}
```

- 딕셔너리 컴프리헨션
    - 구조 : `{ 키 : 값 공식 for 항목 in 반복가능객체 if 조건 }`
- 집합 컴프리헨션
    - 구조: `{ 값 공식 for 항목 in 반복가능객체 if 조건 }`

```python
alt_dict = dict(map(lambda x: (x, x**2),
                filter(lambda x: x % 2 == 0, a)))
alt_set = set(map(lambda x: x**3,
              filter(lambda x: x % 3 == 0, a)))
```

## 28. 컴프리헨션 내부에 제어 하위 식을 세 개 이상 사용하지 말라

```python
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
flat = [x for row in matrix for x in row]
print(flat)
```

```python
[1, 2, 3, 4, 5, 6, 7, 8, 9]
```

- 컴프리헨션 안에 `for` 문이 여러 개 있을 때, 가장 중요한 규칙은 일반적인 `for` 루프를 쓸 때의 순서와 똑같이 적어야함.
- 위의 코드를 일반적인 for 루프로 풀어서 쓰면 아래와 같다.

```python
flat = []
for row in matrix:      # 1. 첫 번째 for 문
    for x in row:       # 2. 두 번째 for 문
        flat.append(x)  # 3. 결과값 (x)
```

```python
squared = [[x**2 for x in row] for row in matrix]
print(squared)
```

- 일반적인 코드로 풀면 다음과 같다

```python
squared = []
for row in matrix:
    new_row = []
    for x in row:
        new_row.append(x**2)
    squared.append(new_row)
```

```python
[[1, 4, 9], [16, 25, 36], [49, 64, 81]]
```

```python
my_lists = [
    [[1, 2, 3], [4, 5, 6]],
    [[7, 8, 9], [1, 2, 3]],
    [[4, 5, 6], [7, 8, 9]],
]
flat = [x for sublist1 in my_lists
        for sublist2 in sublist1
        for x in sublist2]
print(flat)
```

```python
[1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

- `sublist1`: `my_lists`에서 큰 덩어리 하나를 가져온다. (예: `[[1, 2, 3], [4, 5, 6]]`)
- `sublist2`: 방금 가져온 덩어리 안에서 작은 리스트 하나를 가져온다 (예: `[1, 2, 3]`)
- `x`: 마지막으로 그 작은 리스트 안에서 실제 숫자 하나를 꺼낸다.(예: `1`, `2`, `3`)
- 이 과정을 끝까지 반복하면 모든 숫자가 한 줄로 늘어선 `[1, 2, 3, 4, 5, 6, 7, 8, 9, ...]` 리스트가 완성된다.

```python
flat = []
for sublist1 in my_lists:
    for sublist2 in sublist1:
        flat.extend(sublist2)
print(flat)
```

```python
[1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

- `for sublist1 in my_lists:`
    - 가장 바깥쪽 리스트에서 2차원 리스트 덩어리를 하나 꺼낸다.
    - 예: `[[1, 2, 3], [4, 5, 6]]`
- `for sublist2 in sublist1:`
    - 방금 꺼낸 덩어리 안에서 1차원 리스트를 하나 꺼낸다.
    - 예: `[1, 2, 3]`
- `flat.extend(sublist2)`
    - 여기서 `append`를 쓰지 않고 `extend`를 썼다.
    - `append`: 리스트 자체를 통째로 집어넣음 (결과가 `[[1, 2, 3]]`이 됨)
    - `extend`: 리스트 안의 내용물만 쏙 꺼내서 기존 리스트 뒤에 이어 붙임 (결과가 `[1, 2, 3]`이 됨)
    

```python
b = [x for x in a if x > 4 if x % 2 == 0]
```

- 컴프리헨션의 공식 : `b = [ (결과값) for (변수) in (대상) (조건문) ]`
- 작동 순서:
1. `x > 4`인가? (먼저 검사)
2. (위가 참이라면) `x % 2 == 0`인가? (그다음 검사)
- 일반 for 루프로 풀면 다음과 같다

```python
for x in a:
    if x > 4:
        if x % 2 == 0:
            b.append(x)
```

```python
c = [x for x in a if x > 4 and x % 2 == 0]
```

- 작동 순서: `x > 4`와 `x % 2 == 0` 두 조건이 모두 참인지 한꺼번에 검사
- 일반 for 루프로 풀면 다음과 같다

```python
for x in a:
    if x > 4 and x % 2 == 0:
        c.append(x)
```

---

```python
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
filtered = [[x for x in row if x % 3 == 0]
            for row in matrix if sum(row) >= 10]
print(filtered)
```

### 기억해야할 내용

- 컴프리헨션은 여러 수준의 루프를 지원하며 각 수준마다 여러 조건을 지원한다.
    - 컴프리헨션 하나 안에서 `for` 문(루프)을 여러 번 쓸 수 있고, 각 `for` 문마다 `if`(조건)를 붙여서 아주 정교하게 데이터를 뽑아낼 수 있다.
- 제어 하위 식이 세 개 이상인 컴프리헨션은 이해하기 매우 어려우므로 가능하면 피해야한다.

## **29. 대입식을 사용해 컴프리헨션 안에서 반복 작업을 피하라**

```python
stock = {
    '못': 125,
    '나사못': 35,
    '나비너트': 8,
    '와셔': 24,
}

order = ['나사못', '나비너트', '클립']

def get_batches(count, size):
    return count // size

result = {}
for name in order:
    count = stock.get(name, 0)
    batches = get_batches(count, 8)
    if batches:
        result[name] = batches

print(result)
```

```python
{'나사못': 4, '나비너트': 1}
```

```python
found = {name: get_batches(stock.get(name, 0), 8) # 결과값 
         for name in order # 반복문
         if get_batches(stock.get(name, 0), 8)} # 조건문
print(found)
```

```python
{'나사못': 4, '나비너트': 1}
```

- `for name in order`: 주문 목록에서 이름을 하나씩 꺼낸다.
- `if get_batches(stock.get(name, 0), 8)`: (조건문) 묶음 계산 결과가 0이 아닐 때만 통과시킨다.
- `name: get_batches(stock.get(name, 0), 8)`: (결과물) 이름을 키로, 묶음 계산 결과를 값으로 저장한다.
- 똑같은 함수를 두번이나 호출하여 낭비적으로 계산을 하게 됨

```python
has_bug = {name: get_batches(stock.get(name, 0), 4)
           for name in order
           if get_batches(stock.get(name, 0), 8)}

print('예상:', found)
print('실졔: ', has_bug)
```

```python
예상: {'나사못': 4, '나비너트': 1}
실졔:  {'나사못': 8, '나비너트': 2}
```

- 컴프리헨션 안에서 똑같은 로직을 두 번 쓰게 되면(하나는 필터링용, 하나는 저장용), 나중에 코드를 고칠 때 양쪽을 다 고쳐야하는 번거로움이 있다.

```python
found = {name: batches for name in order
         if (batches := get_batches(stock.get(name, 0), 8))}

# 오류가 나는 부분. 오류를 보고 싶으면 커멘트를 해제할것
#result = {name: (tenth := count // 10)
#          for name, count in stock.items() if tenth > 0}
print(found)
```

```python
{'나사못': 4, '나비너트': 1}
```

- 바다코끼리 연산자(Walrus Operator)
    - 일반 대입(`=`) vs 바다코끼리 대입(`:=`)
        - 일반 대입 : "상자에 값을 넣는 행위" 자체
        - 바다코끼리 대입 : “상자에 값을 넣는 행위” + 반환까지
        - 여기서 저장된 batches 는 name:batches 에서 그대로 사용한다

```python
result = {name: (tenth := count // 10)
          for name, count in stock.items() if tenth > 0}
```

- 파이썬 컴프리헨션이 실행될 때, 실제 실행 순서는 다음과 같다.
    1. 반복문(`for`) : 먼저 데이터를 하나 꺼낸다.
    2. 조건문(`if`) : 데이터를 결과에 넣을지 말지 검사한다
    3. 결과생성(`name: (tenth := ...)`)
- 지금 tenth 라는 변수가 태어나지도 않았는데 `if tenth > 0` 를 실행하려고 했기때문에 에러가 발생한다.

```python
# 일반적인 컴프리헨션 변수
half = [c // 2 for c in stock.values()]

print(c)

NameError: name 'd' is not defined
```

```python
#
half = [(last := count // 2) for count in stock.values()]
print(f'{half}의 마지막 원소는 {last}')
```

```python
[62, 17, 4, 12]의 마지막 원소는 12
```

- 변수 누출 (Variable Leakage)
    - 리스트 컴프리헨션 안에서 쓰는 변수는 밖으로 안 나오는 게 파이썬의 규칙이다. 그런데 바다코끼리 연산자는 이 규칙을 깨고 변수를 밖으로 유출시킬 수 있다.

```python
#
for count in stock.values(): # 루프 변수가 누출됨
    pass

print(f'{list(stock.values())}의 마지막 원소는 {count}')
```

```python
[125, 35, 8, 24]의 마지막 원소는 24
```

- **반복 시작:** `stock.values()`에서 숫자들을 하나씩 꺼내 `count`라는 이름표를 붙인다.
- **마지막 바퀴:** 가장 마지막 숫자인 **24**를 꺼내서 `count`에 담는다.
- **루프 종료:** 이제 더 꺼낼 숫자가 없어서 루프가 끝난다.
- 루프가 끝났음에도 불구하고, `count`라는 변수는 메모리에 그대로 남아 있고 가장 마지막에 담겼던 값(24)을 그대로 들고 있다.

```python
#
half = [count // 2 for count in stock.values()]
print(half)  # 작동함
print(count) # 루프 변수가 누출되지 않기 때문에 예외가 발생함
```

- 여기서 `count`는 리스트를 만들기 위해 임시로 사용하는 변수이다.
    - 리스트가 만들어지는 동안에는 `125`, `35`, `8`, `24`라는 값을 차례로 갖게 된다.
    - 결과물인 `half` 리스트는 `[62, 17, 4, 12]`가 되어 저장된다.
- 파이썬은 리스트 컴프리헨션 내부에서 선언된 반복 변수(`count`)를 그 계산이 끝나자마자 메모리에서 완전히 삭제한다.
- `[count // 2 for count in ...]` → `count`는 소멸함 (안전)
- `[(last := count // 2) for count in ...]` → `last` 는 생존 → 유출

```python
#
stock = {
    '못': 125,
    '나사못': 35,
    '나비너트': 8,
    '와셔': 24,
}

order = ['나사못', '나비너트', '클립']

found = ((name, batches) for name in order
         if (batches := get_batches(stock.get(name, 0), 8)))
print(found)
print(next(found))
print(next(found))
```

```python
<generator object <genexpr> at 0x00000219CCAC4E50>
('나사못', 4)
('나비너트', 1)
```

- 지연 계산(Lazy Evaluation): 리스트(`[]`)는 코드가 실행되는 즉시 모든 계산을 끝내고 메모리에 값을 다 올린다. 하지만 제너레이터(`()`)는 요청 받을 때만 계산을 수행한다.

## 30. 리스트를 반환하기 보다는 제너레이터를 사용하라

```python
def index_words(text):
    result = []
    if text:
        result.append(0)
    for index, letter in enumerate(text):
        if letter == ' ':
            result.append(index + 1)
    return result

#
address = '컴퓨터(영어: Computer, 문화어: 콤퓨터, 순화어:전산기)는 진공관'
result = index_words(address)
print(result[:10])
```

```python
[0, 8, 18, 23, 28, 38]
```